# -*- coding: utf-8 -*-
"""Sentiment_Analysis_Using_BERT_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18G1svGQ_I-WQ6EIso2Sm9b6oBJl5eTJ4
"""

!pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio===0.8.1 -f https://download.pytorch.org/whl/torch_stable.html

!pip install transformers requests beautifulsoup4 pandas numpy

"""Transformers provides APIs and tools to easily download and train state-of-the-art pretrained models. Using pretrained models can reduce your compute costs, carbon footprint, and save you the time and resources required to train a model from scratch.

"""

from transformers import AutoTokenizer, AutoModelForSequenceClassification
import torch # used for tensor computation
import requests #The requests module allows you to send HTTP requests using Python.
from bs4 import BeautifulSoup #Beautiful Soup is a Python library for pulling data out of HTML and XML files
import re # "re" module provides regular expression support.
import numpy as np
import pandas as pd

# Loading the pretrained model
tokenizer = AutoTokenizer.from_pretrained('nlptown/bert-base-multilingual-uncased-sentiment')

model = AutoModelForSequenceClassification.from_pretrained('nlptown/bert-base-multilingual-uncased-sentiment')

# Input sentence for test
tokens = tokenizer.encode('What if I dont want it?', return_tensors='pt')

result = model(tokens)

result.logits

int(torch.argmax(result.logits))+1
sentiment ="Neutral"
if int(torch.argmax(result.logits))+1 > 3:
      sentiment ="Yes"
elif int(torch.argmax(result.logits))+1 !=3 and int(torch.argmax(result.logits))+1 < 3:
      sentiment = "No"


sentiment

# Scraping results from a website
r = requests.get('https://www.yelp.com/biz/golden-gate-dental-san-francisco?osq=dentist')
soup = BeautifulSoup(r.text, 'html.parser')
regex = re.compile('.*comment.*')
results = soup.find_all('p', {'class':regex})
reviews = [result.text for result in results]

reviews

df = pd.DataFrame(np.array(reviews), columns=['review'])
df['review'].iloc[0]

def sentiment_score(review):
    tokens = tokenizer.encode(review, return_tensors='pt')
    result = model(tokens)
    sentiment = "Neutral"
    if int(torch.argmax(result.logits))+1 > 3:
      sentiment ="Yes"
    elif int(torch.argmax(result.logits))+1 !=3 && int(torch.argmax(result.logits))+1 < 3:
      sentiment = "No"
    return sentiment
sentiment_score(df['review'].iloc[1])

df['sentiment'] = df['review'].apply(lambda x: sentiment_score(x[:512]))

# df['review'].iloc[3]

df

import matplotlib.pyplot as plt
add = 0
one=two=three=four=five=0
for i in range(0, len(df.sentiment)):
  add = df['sentiment'].iloc[i] + add
  if df['sentiment'].iloc[i] == 1:
    one+=1
  if df['sentiment'].iloc[i] == 2: two+=1
  if df['sentiment'].iloc[i] == 3:three+=1
  if df['sentiment'].iloc[i] == 4:four+=1
  if df['sentiment'].iloc[i] == 5:five+=1
avg_rating = add/len(df.sentiment)
graph_data = {'Ratings': [1,2,3,4,5],
    'Number of Reviews':[one, two, three, four, five]
}
df_graph = pd.DataFrame(graph_data, columns=['Ratings','Number of Reviews'])
df_graph.plot(x='Ratings', y='Number of Reviews', kind ='bar')
avg_rating